# Princípios SOLID

## Introdução

O manual a seguir aborda os princípios SOLID, um conjunto de diretrizes para o design de software orientado a objetos que visa criar sistemas mais flexíveis, escaláveis e fáceis de manter. Os cinco princípios SOLID são:

- [Princípios SOLID](#princípios-solid)
  - [Introdução](#introdução)
  - [Princípio da Responsabilidade Única (SRP)](#princípio-da-responsabilidade-única-srp)
  - [Princípio do Aberto/Fechado (OCP)](#princípio-do-abertofechado-ocp)
  - [Princípio da Substituição de Liskov (LSP)](#princípio-da-substituição-de-liskov-lsp)
  - [Princípio da Segregação de Interfaces (ISP)](#princípio-da-segregação-de-interfaces-isp)
  - [Princípio da Inversão de Dependência (DIP)](#princípio-da-inversão-de-dependência-dip)
  - [Conclusão](#conclusão)

## Princípio da Responsabilidade Única (SRP)

- Uma classe deve ter apenas uma razão para mudar.
- Evita classes com muitas responsabilidades.
- Melhora a manutenibilidade e compreensão do código.

## Princípio do Aberto/Fechado (OCP)

- Entidades devem estar abertas para extensão e fechadas para modificação.
- Adição de funcionalidades sem alterar o código existente.
- Utilização de herança, polimorfismo e composição.

## Princípio da Substituição de Liskov (LSP)

- Subtipos devem ser substituíveis por seus tipos de base.
- Garante consistência de comportamento nas hierarquias de classes.
- Evita surpresas ao substituir objetos derivados.

## Princípio da Segregação de Interfaces (ISP)

- Muitas interfaces específicas são melhores do que uma interface generalizada.
- Evita que classes implementem métodos desnecessários.
- Reduz o acoplamento e melhora a coesão.

## Princípio da Inversão de Dependência (DIP)

- Módulos de alto nível não devem depender de módulos de baixo nível.
- Ambos devem depender de abstrações.
- Reduz o acoplamento e permite trocar implementações facilmente.

## Conclusão

Dominar os princípios SOLID é fundamental para criar código limpo, modular e resiliente. Ao aplicar esses princípios, você estará preparado para desenvolver sistemas de software mais robustos e flexíveis.

